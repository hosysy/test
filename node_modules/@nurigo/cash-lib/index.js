// vi:set sw=2 ts=2 expandtab:
'use strict'

const AWS = require('aws-sdk')
const config = require('./config.json')
AWS.config.update({
  'region': config.region,
  'accessKeyId': config.awsKey,
  'secretAccessKey': config.awsSecret
})
const Lambda = new AWS.Lambda()

const request = require('./lib/request.js')
const keygen = require('keygenerator')

var unit = {}

// 잔액정보
unit.getBalance = function getBalance (useDev = false) {
  return new Promise((resolve, reject) => {
    let prefix = config.prefixProd
    if (useDev) prefix = config.prefixDev
    let functionName = `${prefix}getCashInfo`
    request.invoke(functionName,
      {user_id: 'cooltest'},
      (err, res) => {
        if (err) return reject(err)
        return resolve(res)
      })
  })
}

// 캐쉬 차감 REST v1, 2
unit.deductCash = function deductCash (useDev = false) {
  return new Promise((resolve, reject) => {
    let payload = {
      'member_srl': '12925149',
      'user_id': 'cooltest',
      'cash': 20,
      'type': 'deduct'
    }

    module.exports.deductCash(payload, useDev).then((res) => {
      return resolve(res)
    })
    .catch((err) => {
      return reject(err)
    })
  })
}

// 캐쉬 충전 REST v1, 2
unit.rechargeCash = function rechargeCash (useDev = false) {
  return new Promise((resolve, reject) => {
    let payload = {
      'member_srl': '12925149',
      'user_id': 'cooltest',
      'cash': 20,
      'type': 'recharge'
    }

    module.exports.deductCash(payload, useDev).then((res) => {
      return resolve(res)
    })
    .catch((err) => {
      return reject(err)
    })
  })
}

// 캐쉬 차감 REST v3
unit.deductCashV3 = function deductCashV3 (useDev = false) {
  return new Promise((resolve, reject) => {
    let payload = {
      'member_srl': '9131450',
      'user_id': 'testsy1',
      'messages': {
        'sms': 1
      },
      'simulation': 'true',
      'sync': 'true'
    }

    module.exports.deductCashByType(payload, useDev).then((res) => {
      return resolve(res)
    })
    .catch((err) => {
      return reject(err)
    })
  })
}

module.exports = {
  deductCashByType: (payload, useDev = false) => {
    return new Promise((resolve, reject) => {
      if (payload.constructor !== Object) return reject("Data type is not 'object'")
      payload.unique_key = keygen._()

      let prefix = config.prefixProd
      if (useDev) prefix = config.prefixDev
      let functionName = `${prefix}putCashInfoToRedisByType`

      Lambda.invoke({
        FunctionName: functionName,
        Payload: JSON.stringify(payload)
      }, (err, data) => {
        if (err) return reject(JSON.stringify(err))

        data = JSON.parse(data.Payload)

        if ('errorMessage' in data) {
          return reject(JSON.parse(data.errorMessage))
        }
        return resolve(data)
      })
    })
  },
  deductCash: (payload, useDev = false) => {
    return new Promise((resolve, reject) => {
      if (payload.constructor !== Object) return reject("Data type is not 'object'")
      payload.unique_key = keygen._()

      let prefix = config.prefixProd
      if (useDev) prefix = config.prefixDev
      let functionName = `${prefix}putCashInfoToRedis`

      Lambda.invoke({
        FunctionName: functionName,
        Payload: JSON.stringify(payload)
      }, (err, data) => {
        if (err) return reject(JSON.stringify(err))

        if ('errorMessage' in data) {
          return reject(JSON.parse(data.errorMessage))
        }
        return resolve(JSON.parse(data.Payload))
      })
    })
  },
  getBalance: (payload, useDev = false) => {
    return new Promise((resolve, reject) => {
      if (payload.constructor !== Object) return reject("Data type is not 'object'")

      let prefix = config.prefixProd
      if (useDev) prefix = config.prefixDev
      let functionName = `${prefix}getCashInfo`

      Lambda.invoke({
        FunctionName: functionName,
        Payload: JSON.stringify(payload)
      }, (err, data) => {
        if (err) return reject(JSON.stringify(err))

        if ('errorMessage' in data) {
          return reject(JSON.parse(data.errorMessage))
        }
        return resolve(JSON.parse(data.Payload))
      })
    })
  },
  unitTest: (functionName, useDev = false) => {
    return new Promise((resolve, reject) => {
      if (!(functionName in unit) || !(typeof unit[functionName] === 'function')) {
        return reject('function is not found')
      }

      unit[functionName](useDev).then((res) => {
        return resolve(res)
      })
      .catch((reason) => {
        return reject(reason)
      })
    })
  }
}
