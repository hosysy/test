'use strict'

module.exports = function(mongoose, modelList, modelPath, cache, ttl, lean) {
  const exec = mongoose.Query.prototype.exec
  let allowData = {}

  /**
   * 쿼리 실행 시 사용 되며 쿼리에 따라 캐시 사용여부를 판단 후 기존 쿼리 혹은 캐시를 사용하도록 한다
   */
  mongoose.Query.prototype.exec = async function(op, callback = function() { }) {
    if (typeof op === 'function') callback = op
    if (typeof op === 'string') this.op = op

    try {
      const model = this.model.modelName
      this._mongooseOptions.lean = lean // lean 설정
      const res = await checkUseCacheBefore(this, modelList, model)
      if (res) return await execUseCache(this, res, callback)
      return exec.apply(this, arguments)
    } catch (err) {
      console.error(`mongoose-cache:checkUseCacheError: ${err.message}`)
      return exec.apply(this, arguments)
    }
  }

  /**
   * key 필드외에 허가한 필드의 데이터를 파싱
   */
  function allowFieldsParser(key, data, allowFields) {
    let results = ''
    if (allowFields.indexOf(key) > -1) {
      allowData[key] = data[key]
    } else {
      if (Object.prototype.toString.call(data) === '[object String]') {
        results = ':' + data
      } else if (Object.prototype.toString.call(data) === '[object Array]') {
        results = ':' + data[key].join()
      } else {
        results = ':' + data[key]
      }
    }
    return results
  }

  /**
   * 들어온 데이터 값을 상황에 맞게 변환
   */
  function dataParser(data, allowFields) {
    for(let key in data) {
      if (Object.prototype.toString.call(data[key]) === '[object Array]') {
        return allowFieldsParser(key, data, allowFields)
      } else if (Object.prototype.toString.call(data[key]) === '[object Object]') {
        for(let key2 in data[key]) {
          if (Object.prototype.toString.call(data[key][key2]) === '[object Array]') {
            return allowFieldsParser(key2, data[key], allowFields)
          }
          return dataParser(data[key][key2], allowFields)
        }
      } 
      return allowFieldsParser(key, data, allowFields)
    }
  }

  /**
   * array로 들어온 데이터 값을 dataParser를 호출하여 변환
   */
  function arrayParser(data, allowFields) {
    let result = ''
    data.forEach(function(obj) {
      result += dataParser(obj, allowFields)
    })
    return result
  }

  /**
   * mongoose object로 변환 후 들어가지 않은 값이나 삭제해야 할 값이 있다면 처리
   */
  function objectKeySet(obj, compareObj, fields) {
    let itemsProcessed = 0
    for (let key in compareObj) {
      obj._doc[key] = compareObj[key]
    }

    if (fields && Object.keys(fields).length > 0) {
      for (let key in fields) {
        if (!fields[key]) delete obj._doc[key]
      }
    }
    return obj
  }

  /**
   * object를 mongoose object로 변환
   */
  function convertToMongooseObject(query, results) {
    try {
      const models = require(modelPath)
      const modelName = query.model.modelName
      const Schema  = models[modelName]

      if (Object.prototype.toString.call(results) === '[object Array]') {
        return results.map((obj) => {
          let res = new Schema(obj)
          
          if (Object.keys(res._doc).length !== Object.keys(obj).length) return obj
          return res
        })
      } else if (Object.prototype.toString.call(results) === '[object Object]') {
        let res = new Schema(results, Object.keys(results))
        res = objectKeySet(res, results, query._fields)
        
        return res
      } else {
        return results
      }
    } catch (err) {
      throw err
    }
  }

  /**
   * query 실행 전에 캐시 사용 여부를 판단
   */
  function checkUseCacheBefore(query, modelList, model) {
    return new Promise((resolve, reject) => {
      const conditions = query._conditions
      let itemsProcessed = 0
      let key = ''
      let condition

      // skip이나 limit등 조건이 있으면 캐시하지 않음
      if (Object.keys(query.options).length > 0 && !('upsert' in query.options)) {
        return resolve(false)
      }

      const posibleQuery = [ 'find', 'findOne', 'update', 'count' ]
      if (!posibleQuery.includes(query.op)) return resolve(false)

      modelList.forEach(function(obj) {
        if (obj.name === model && Object.keys(conditions).every(function(u, i) {
          let allowFields = 'allowFields' in obj ? obj.allowFields : []
          allowData = allowFields
          
          // 넘어온 조건에 따라서 키 값을 다르게 변환
          if (Object.prototype.toString.call(conditions[u]) === '[object Object]') {
            condition = dataParser(conditions[u], allowFields)
          } else if (Object.prototype.toString.call(conditions[u]) === '[object Array]') {
            condition = arrayParser(conditions[u], allowFields)
          } else {
            condition = ':' + conditions[u]
          }

          // populate 같은 경우 '_id'로 찾기 때문에 obj.key의 0번째 값을 키값으로 사용
          if (u === '_id') u = obj.key[0]

          // condition이 string이 아니라면 return
          if (Object.prototype.toString.call(condition) !== '[object String]') {
            return resolve(false)
          }

          key += condition

          // 넘어온 조건이 사전에 정의해둔 model key값과 맞으면 true
          if (Object.prototype.toString.call(conditions[u]) === '[object Array]') {
            for (const obj2 of conditions[u]) {
              if ((obj.key.indexOf(u) > -1) || (obj.allowFields && obj.allowFields.indexOf(u) > -1)) {
                return true
              }
              return resolve(false)
            }
            return true
          } else {
            return obj.key.indexOf(u) > -1
          }
        })) {
          key = `${model}${key}`
          if (query.op !== 'update') key += `:${query.op}`
          return resolve(key)
        }

        itemsProcessed++
        if(itemsProcessed === modelList.length) {
          return resolve(false);
        }
      })
    })
  }

  /**
   * 캐시를 통해 가져온 값의 사용 여부를 판단
   * 아래와 같은 상황일 때 캐시 데이터 리턴
   *  - 이전에 생성된 캐시 데이터가 있을 때 데이터가 생성된지 5초가 지나지 않았을때
   *  - UPDATE가 아닐때
   *  - mongodb에 정상적으로 접속이 안되었을때
   *  - allowFields이용시 allowData와 가져온 캐시데이터의 값이 같을때
   */
  function checkUseCacheAfter(query, results) {
    try {
      const conditions = query._conditions
      const mongoState = mongoose.connection.readyState
      let compareDate = new Date();
      compareDate.setSeconds(compareDate.getSeconds() - 5);

      if (query.op === 'update') return false
      if (mongoState !== 1) return true

      if (allowData.length > 0) {
        for (let key in allowData) {
          if (!results._mongoData[key] !== allowData[key]) return false
        }
      }

      if (Object.prototype.toString.call(results) === '[object Object]') {
        if ('_id' in conditions) {
          if ('$in' in conditions._id) {
            return false
          }
        }
        if (new Date(results._iat) > compareDate) {
          return true
        }
      }
      
      return false
    } catch(err) {
      return false
    }
  }

  /**
   * 쿼리에 캐시를 이용하도록 하며 조건에 맞는다면 캐시데이터를 리턴한다.
   */
  function execUseCache(query, key, callback) {
    // console.log('check Key : ' + key)
    return new Promise((resolve, reject) => {
      cache.get(key, async (err, cachedResults) => {
        if (cachedResults) {
          // 가져온 캐시 데이터의 사용 여부 체크
          if (checkUseCacheAfter(query, cachedResults)) {
            try {
              const results = await convertToMongooseObject(query, cachedResults._mongoData)
              callback(null, results)
              return resolve(results)
            } catch (err) {
              console.error('get cache data error : ' + err.toString())
            }
          }
        }

        // mongodb query 실행 후 캐시 데이터 생성
        exec
          .call(query)
          .then((results) => {
            // update때는 캐시 삭제
            if (query.op === 'update') {
              cache.del(key + '*', () => resolve(results))
            } else {
              if (results === null) return resolve(results)
              results = convertToMongooseObject(query, results)
              
              // select때는 캐시 생성
              let cacheData = { '_mongoData': results, _iat: new Date() }
              cache.set(key, cacheData, ttl, () => {
                callback(null, results)
                return resolve(results)
              })
            }
          })
          .catch((err) => {
            callback(err)
            reject(err)
          })
      })
    })
  }
}
